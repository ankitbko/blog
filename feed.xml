<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://ankitbko.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ankitbko.github.io/blog/" rel="alternate" type="text/html" /><updated>2025-08-18T15:55:34-05:00</updated><id>https://ankitbko.github.io/blog/feed.xml</id><title type="html">F5 - Squashing Bugs</title><subtitle>A technology blog focusing on random stuff</subtitle><author><name>Ankit Sinha</name></author><entry><title type="html">KV-Cache Aware Prompt Engineering - How Stable Prefixes Unlock 65% Latency Improvements</title><link href="https://ankitbko.github.io/blog/2025/08/prompt-engineering-kv-cache/" rel="alternate" type="text/html" title="KV-Cache Aware Prompt Engineering - How Stable Prefixes Unlock 65% Latency Improvements" /><published>2025-08-18T00:00:00-05:00</published><updated>2025-08-18T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2025/08/prompt-engineering-kv-cache</id><author><name>&lt;a href='https://twitter.com/ankitbko', target='_blank'&gt;Ankit Sinha&lt;/a&gt;</name></author><category term="AI" /><category term="ML" /><category term="LLM" /><category term="Large Language Model" /><category term="KV Cache" /><category term="Prompt Engineering" /><category term="OpenAI" /><summary type="html">Ever wondered why some AI applications feel lightning-fast while others seem sluggish? The secret often lies in something called the KV cache – a clever optimization in transformer models that’s like having a really good memory for previous conversations.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ankitbko.github.io/blog/images/previews/kv-cache.png" /><media:content medium="image" url="https://ankitbko.github.io/blog/images/previews/kv-cache.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Patterns for Vision on the Edge - Part 2 - Handling Multiple Consumers</title><link href="https://ankitbko.github.io/blog/2022/06/vision-on-edge-part-2/" rel="alternate" type="text/html" title="Patterns for Vision on the Edge - Part 2 - Handling Multiple Consumers" /><published>2022-06-30T00:00:00-05:00</published><updated>2022-06-30T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2022/06/vision-on-edge-part-2</id><author><name>&lt;a href='https://twitter.com/ankitbko', target='_blank'&gt;Ankit Sinha&lt;/a&gt;, &lt;a href='https://github.com/prabdeb', target='_blank'&gt;Prabal Deb&lt;/a&gt;</name></author><category term="AI" /><category term="ML" /><category term="vision on edge" /><category term="python" /><category term="multiprocessing" /><category term="threading" /><category term="GIL" /><category term="back-pressure" /><category term="reactivex" /><category term="rxpy" /><summary type="html">This post is the second part in a 2 part blog series on Patterns for implementing Vision on Edge. In the previous post, we discussed two of the three common challenges faced when creating a Computer Vision based solution using Python on Edge.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ankitbko.github.io/blog/images/previews/vision-on-edge-2.png" /><media:content medium="image" url="https://ankitbko.github.io/blog/images/previews/vision-on-edge-2.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Patterns for Vision on the Edge - Part 1 - Concurrent processing</title><link href="https://ankitbko.github.io/blog/2022/06/vision-on-edge-part-1/" rel="alternate" type="text/html" title="Patterns for Vision on the Edge - Part 1 - Concurrent processing" /><published>2022-06-29T00:00:00-05:00</published><updated>2022-06-29T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2022/06/vision-on-edge-part-1</id><author><name>&lt;a href='https://twitter.com/ankitbko', target='_blank'&gt;Ankit Sinha&lt;/a&gt;, &lt;a href='https://github.com/prabdeb', target='_blank'&gt;Prabal Deb&lt;/a&gt;</name></author><category term="AI" /><category term="ML" /><category term="vision on edge" /><category term="python" /><category term="multiprocessing" /><category term="threading" /><category term="GIL" /><category term="back-pressure" /><summary type="html">While developing a solution for implementing vision on the edge use case, one of the most common requirement is having the ability to ingest live video feed and process it to derive useful insights (running a ML model on the captured frame, etc.).</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ankitbko.github.io/blog/images/previews/vision-on-edge-1.png" /><media:content medium="image" url="https://ankitbko.github.io/blog/images/previews/vision-on-edge-1.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Optimizing network footprint using MessagePack</title><link href="https://ankitbko.github.io/blog/2022/06/messagepack-vs-base64/" rel="alternate" type="text/html" title="Optimizing network footprint using MessagePack" /><published>2022-06-23T00:00:00-05:00</published><updated>2022-06-23T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2022/06/messagepack-vs-base64</id><author><name>&lt;a href='https://twitter.com/ankitbko', target='_blank'&gt;Ankit Sinha&lt;/a&gt;, &lt;a href='https://github.com/prabdeb', target='_blank'&gt;Prabal Deb&lt;/a&gt;</name></author><category term="websocket" /><category term="python" /><category term="performance" /><category term="latency" /><category term="complexity" /><category term="messagepack" /><category term="base64" /><category term="json" /><summary type="html">The most commonly used technique to send binary data from server to client is to encode it using Base64 and send it as JSON. Base64 encodes each set of three bytes into four bytes. In addition the output will be padded to always be multiple of four. So the final output would be 4/3 or 33% larger than the original data. Add overhead of JSON to it and output grows even larger. In most of the scenarios this overhead is negligible and worth paying the cost in return of ease of integration with other applications as most of the languages or frameworks have native support of Base64 encoding.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ankitbko.github.io/blog/images/previews/messagepack.png" /><media:content medium="image" url="https://ankitbko.github.io/blog/images/previews/messagepack.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Measuring latency of Websocket Messages</title><link href="https://ankitbko.github.io/blog/2022/06/websocket-latency/" rel="alternate" type="text/html" title="Measuring latency of Websocket Messages" /><published>2022-06-22T00:00:00-05:00</published><updated>2022-06-22T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2022/06/websocket-latency</id><author><name>&lt;a href='https://twitter.com/ankitbko', target='_blank'&gt;Ankit Sinha&lt;/a&gt;, &lt;a href='https://github.com/prabdeb', target='_blank'&gt;Prabal Deb&lt;/a&gt;</name></author><category term="websocket" /><category term="python" /><category term="performance" /><category term="latency" /><summary type="html">Have you noticed that the browser does not display time it took for a websocket message to be delivered like it shows for HTTP requests? That is because, in contrast to HTTP protocol which follows request-response pattern, websocket messages do not have transaction semantics once the initial handshake is done to establish the connection. Once the websocket connection is established, messages are pushed from server to client (or vice versa). Therefore if browser receives a websocket message, it does not know when the message was sent to calculate the latency.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ankitbko.github.io/blog/images/previews/websocket_latency.png" /><media:content medium="image" url="https://ankitbko.github.io/blog/images/previews/websocket_latency.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">STEADY by AID with ART</title><link href="https://ankitbko.github.io/blog/2021/07/steady-by-aid-with-art/" rel="alternate" type="text/html" title="STEADY by AID with ART" /><published>2021-07-30T00:00:00-05:00</published><updated>2021-07-30T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2021/07/steady-by-aid-with-art</id><author><name>&lt;a href='https://twitter.com/ankitbko', target='_blank'&gt;Ankit Sinha&lt;/a&gt;</name></author><category term="design" /><category term="software design" /><category term="principles" /><category term="architecture" /><summary type="html">This post is heavily inspired by Hints and Principles for Computer System Design by Butler Lampson and is derived from my notes when reading the paper. My goal of this article was to condense information in Butler’s paper into short actionable article that can be referenced when designing software. I strongly recommend reading the original paper.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ankitbko.github.io/blog/images/previews/steady-by-aid.jpg" /><media:content medium="image" url="https://ankitbko.github.io/blog/images/previews/steady-by-aid.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">A better way to logging in Python</title><link href="https://ankitbko.github.io/blog/2021/04/logging-in-python/" rel="alternate" type="text/html" title="A better way to logging in Python" /><published>2021-04-15T00:00:00-05:00</published><updated>2021-04-15T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2021/04/logging-in-python</id><author><name>&lt;a href='https://twitter.com/ankitbko', target='_blank'&gt;Ankit Sinha&lt;/a&gt;</name></author><category term="python" /><category term="decorators" /><summary type="html">Any production application will likely have some guidelines regarding how and what needs to be logged in your application. More often these guidelines stem from common industry patterns such as “log all exceptions”. However implementing these guidelines are left to individual developers and leads to same set of logging statements repeated throughout the codebase. For instance to log all exceptions you would have a logging statement in every except block that captures exception and logs it under ERROR level. But the logging statement for same scenario may differ between developers due to their individual style of development. Overtime this leads to fragmented and inconsistent logging in the application. Moreover developers can make mistake and miss having logging statement at necessary places.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ankitbko.github.io/blog/images/previews/python-logging.jpg" /><media:content medium="image" url="https://ankitbko.github.io/blog/images/previews/python-logging.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Azure Devops Pull Request Extension for VS Code</title><link href="https://ankitbko.github.io/blog/2021/01/azdo-pr-vscode-extension/" rel="alternate" type="text/html" title="Azure Devops Pull Request Extension for VS Code" /><published>2021-01-16T00:00:00-06:00</published><updated>2021-01-16T00:00:00-06:00</updated><id>https://ankitbko.github.io/blog/2021/01/azdo-pr-vscode-extension</id><author><name>Ankit Sinha</name></author><category term="azdo" /><category term="azure devops" /><category term="pull request" /><category term="code review" /><category term="vscode" /><summary type="html">Marketplace: https://marketplace.visualstudio.com/items?itemName=ankitbko.vscode-pull-request-azdo.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ankitbko.github.io/blog/images/previews/azdo-pr-vscode-extension.jpg" /><media:content medium="image" url="https://ankitbko.github.io/blog/images/previews/azdo-pr-vscode-extension.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Building large scale data ingestion solutions for Azure SQL using Azure databricks - Part 3</title><link href="https://ankitbko.github.io/blog/2020/09/bulk-import-using-sql-spark-connector-p3/" rel="alternate" type="text/html" title="Building large scale data ingestion solutions for Azure SQL using Azure databricks - Part 3" /><published>2020-09-08T00:00:00-05:00</published><updated>2020-09-08T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2020/09/bulk-import-using-sql-spark-connector-p3</id><author><name>&lt;a href='https://twitter.com/ankitbko', target='_blank'&gt;Ankit Sinha&lt;/a&gt;, &lt;a href='https://srikantan67.blogspot.com/' target='_blank'&gt;Srikantan Sankaran&lt;/a&gt;</name></author><category term="spark" /><category term="Azure Databricks" /><category term="Azure SQL" /><category term="data ingestion" /><category term="SQL spark connector" /><category term="big data" /><category term="python" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ankitbko.github.io/blog/images/previews/spark-connector-3-preview.png" /><media:content medium="image" url="https://ankitbko.github.io/blog/images/previews/spark-connector-3-preview.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Building large scale data ingestion solutions for Azure SQL using Azure databricks - Part 2</title><link href="https://ankitbko.github.io/blog/2020/09/bulk-import-using-sql-spark-connector-p2/" rel="alternate" type="text/html" title="Building large scale data ingestion solutions for Azure SQL using Azure databricks - Part 2" /><published>2020-09-03T00:00:00-05:00</published><updated>2020-09-03T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2020/09/bulk-import-using-sql-spark-connector-p2</id><author><name>&lt;a href='https://twitter.com/ankitbko', target='_blank'&gt;Ankit Sinha&lt;/a&gt;, &lt;a href='https://srikantan67.blogspot.com/' target='_blank'&gt;Srikantan Sankaran&lt;/a&gt;</name></author><category term="spark" /><category term="Azure Databricks" /><category term="Azure SQL" /><category term="data ingestion" /><category term="SQL spark connector" /><category term="big data" /><category term="python" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ankitbko.github.io/blog/images/previews/spark-connector-2-preview.png" /><media:content medium="image" url="https://ankitbko.github.io/blog/images/previews/spark-connector-2-preview.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Building large scale data ingestion solutions for Azure SQL using Azure databricks - Part 1</title><link href="https://ankitbko.github.io/blog/2020/09/bulk-import-using-sql-spark-connector-p1/" rel="alternate" type="text/html" title="Building large scale data ingestion solutions for Azure SQL using Azure databricks - Part 1" /><published>2020-09-01T00:00:00-05:00</published><updated>2020-09-01T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2020/09/bulk-import-using-sql-spark-connector-p1</id><author><name>Ankit Sinha</name></author><category term="spark" /><category term="Azure Databricks" /><category term="Azure SQL" /><category term="data ingestion" /><category term="SQL spark connector" /><category term="big data" /><category term="python" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ankitbko.github.io/blog/images/previews/spark-connector-1-preview.svg" /><media:content medium="image" url="https://ankitbko.github.io/blog/images/previews/spark-connector-1-preview.svg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Device Code Flow in Azure AD using Python’s requests module and MSAL</title><link href="https://ankitbko.github.io/blog/2020/08/device-code-flow-using-msal-in-python/" rel="alternate" type="text/html" title="Device Code Flow in Azure AD using Python’s requests module and MSAL" /><published>2020-08-17T00:00:00-05:00</published><updated>2020-08-17T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2020/08/device-code-flow-using-msal-in-python</id><author><name>Ankit Sinha</name></author><category term="Python" /><category term="azure" /><category term="oauth" /><category term="msal" /><category term="requests" /><category term="device code" /><summary type="html">Repo: https://github.com/ankitbko/python-requests-msal.</summary></entry><entry><title type="html">Modernizing a legacy application</title><link href="https://ankitbko.github.io/blog/2020/02/migrating-legacy-application-to-cloud/" rel="alternate" type="text/html" title="Modernizing a legacy application" /><published>2020-02-17T00:00:00-06:00</published><updated>2020-02-17T00:00:00-06:00</updated><id>https://ankitbko.github.io/blog/2020/02/migrating-legacy-application-to-cloud</id><author><name>Ankit Sinha</name></author><category term="asp.net core" /><category term="wcf" /><category term="legacy" /><category term="migration" /><category term="azure" /><summary type="html">This blog was co-authored by Srikantan Sankaran. You can follow him on twitter and on his blog.</summary></entry><entry><title type="html">Electron-Forge + React + TypeScript = Awesome!</title><link href="https://ankitbko.github.io/blog/2019/08/electron-forge-with-react-and-typescript/" rel="alternate" type="text/html" title="Electron-Forge + React + TypeScript = Awesome!" /><published>2019-08-26T00:00:00-05:00</published><updated>2019-08-26T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2019/08/electron-forge-with-react-and-typescript</id><author><name>Ankit Sinha</name></author><category term="React" /><category term="TypeScript" /><category term="Electron" /><category term="Javascript" /><category term="Electron Forge" /><category term="node" /><summary type="html">Recently I wanted start a new project on Electron and chose React to design UI. Having no prior experience in developing Electron App, I sat down to do some research. The Electron Documentation states two ways to start an electron project, Boilerplate or CLI, with a slight lean towards CLI.</summary></entry><entry><title type="html">Transferring chat to a human agent using Microsoft Bot Framework</title><link href="https://ankitbko.github.io/blog/2017/03/human-handover-bot/" rel="alternate" type="text/html" title="Transferring chat to a human agent using Microsoft Bot Framework" /><published>2017-03-28T00:00:00-05:00</published><updated>2017-03-28T00:00:00-05:00</updated><id>https://ankitbko.github.io/blog/2017/03/human-handover-bot</id><author><name>Ankit Sinha</name></author><category term="Microsoft Bot Framework" /><category term="Bots" /><category term="Chat Bots" /><category term="Conversational Apps" /><category term="Agent" /><category term="Human" /><category term="Live Agent Transfer" /><summary type="html">Source Code: Human Handover Bot</summary></entry></feed>