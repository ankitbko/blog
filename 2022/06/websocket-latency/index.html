<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Measuring latency of Websocket Messages</h1><p class="page-description">Pattern for measuring websocket messages latency</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-06-22T00:00:00-05:00" itemprop="datePublished">
        Jun 22, 2022
      </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name"><a href='https://twitter.com/ankitbko', target='_blank'>Ankit Sinha</a>, <a href='https://github.com/prabdeb', target='_blank'>Prabal Deb</a></span></span>
       • <span class="read-time" title="Estimated read time">
    
    
      3 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/blog/categories/#websocket">websocket</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#python">python</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#performance">performance</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#latency">latency</a>
        
      
      </p>
    

    
		<div class="d-flex flex-wrap flex-justify-start flex-items-center">
			<p class="page-description" style="margin-right: .5rem;">Source Code </p>
			<div class="page-description">
				<div class="px-2">
    <a href="https://github.com/ankitbko/websocket-latency" role="button" target="_blank">
        <img class="notebook-badge-image" src="/blog/assets/badges/github.svg" alt="View On GitHub">
    </a>
</div>

			</div>
		</div>
	
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Have you noticed that the browser does not display time it took for a websocket message to be delivered like it shows for HTTP requests? That is because, in contrast to HTTP protocol which follows <em>request-response</em> pattern, websocket messages do not have transaction semantics once the initial handshake is done to establish the connection. Once the websocket connection is established, messages are <em>pushed</em> from server to client (or vice versa). Therefore if browser receives a websocket message, it does not know when the message was sent to calculate the latency.</p>

<p>Therefore, an obvious approach would be to have sender attach a timestamp to the message while sending so that it can be used to calculate latency. However, the system clocks for both the system could be different which may be skewed or misleading. Hence, sender’s timestamp may not provide sufficient information to calculate latency of message.</p>

<p>To accurately calculate latency we would need round trip of message between client and server. If the original message is small in size and socket is not throttled, the client can echo the same message back to server. The server can then find the roundtrip latency by calculating the time elapsed between sending of original message and receiving the echo’d message. Dividing this by 2 gives one way latency. However if the message size is big, this approach is not recommended as it puts additional stress on socket connection and on the server. In this case we need one additional message to be sent from server to client.</p>

<p><img src="/blog/assets/images/posts/websocket-latency/ws_sequence.png" alt="ws sequence diagram" /></p>

<ol>
  <li>Server sends the Message (M) to client whose latency needs to be measured. Server adds <code class="language-plaintext highlighter-rouge">server_ts</code> to the message.</li>
  <li>Client sends an acknowledgement message (ACK) to server by echoing <code class="language-plaintext highlighter-rouge">server_ts</code> and attaching its own timestamp in <code class="language-plaintext highlighter-rouge">client_ts</code>.</li>
  <li>Server echos the ACK message by attaching another timestamp <code class="language-plaintext highlighter-rouge">server_ack_ts</code>.</li>
  <li>Client captures the timestamp <code class="language-plaintext highlighter-rouge">client_ack_ts</code> onces it receives the ACK message.</li>
</ol>

<p>At this stage the client has 4 pieces of information -</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">server_ts</code>: Timestamp when original message M was sent from server.</li>
  <li><code class="language-plaintext highlighter-rouge">client_ts</code>: Timestamp when original message M was received by the client.</li>
  <li><code class="language-plaintext highlighter-rouge">server_ack_ts</code>: Timestamp when ACK message was received by the server.</li>
  <li><code class="language-plaintext highlighter-rouge">client_ack_ts</code>: Timestamp when ACK response was received by the client.</li>
</ol>

<p>By using these timestamp we can calculate the latency of original message M as follows</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Latency of M = (server_ack_ts - server_ts) - ((client_ack_ts - client_ts) * 0.5)
</code></pre></div></div>

<p>This works because we are only subtracting server timestamp with server timestamp and client timestamp with client timestamp.</p>

<p><img src="/blog/assets/images/posts/websocket-latency/websocket_latency.gif" alt="ws_workflow" /></p>

<p>The code provided implements this in a python application that sends an image multiple times from server to client using websocket. This is analogous to streaming a video from server to client. To run the application</p>

<ol>
  <li>Install dependencies using <code class="language-plaintext highlighter-rouge">pip install -r requirements.txt</code>.</li>
  <li>Run the application by executing <code class="language-plaintext highlighter-rouge">python main.py</code></li>
  <li>Navigate to <code class="language-plaintext highlighter-rouge">http://localhost:7001</code> and open the browser’s console. Click on <em>start</em> button and the latency for each socket message will be printed in the console.</li>
</ol>

<p><img src="/blog/assets/images/posts/websocket-latency/browser_latency.png" alt="Ws Latency" /></p>

<p>The python implementation to handle <em>ACK</em> message and attach appropriate timestamp is in <code class="language-plaintext highlighter-rouge">latency.py</code> as a decorator method.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">measure_latency</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper_measure_latency</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">_self</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">message</span><span class="p">[</span><span class="s">"type"</span><span class="p">]</span> <span class="o">==</span> <span class="s">"ack"</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">f"Received message: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
            <span class="n">message</span><span class="p">[</span><span class="s">"server_ack_ts"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">().</span><span class="n">timestamp</span><span class="p">())</span>
            <span class="n">_self</span><span class="p">.</span><span class="n">write_message</span><span class="p">(</span><span class="n">json</span><span class="p">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">return</span> <span class="n">wrapper_measure_latency</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">index.html</code> the <code class="language-plaintext highlighter-rouge">calculate_socket_latency</code> calculates the latency after all the timestamps are received by the client.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">calculate_socket_latency</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">client_ack_ts</span> <span class="o">=</span> <span class="nx">performance</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span>
    <span class="nx">ack_round_trip_time</span> <span class="o">=</span> <span class="nx">client_ack_ts</span> <span class="o">-</span> <span class="nx">data</span><span class="p">.</span><span class="nx">client_ts</span>
    <span class="nx">ack_one_way</span> <span class="o">=</span> <span class="nx">ack_round_trip_time</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="nx">vid_round_trip_time</span> <span class="o">=</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">server_ack_ts</span> <span class="o">-</span> <span class="nx">data</span><span class="p">.</span><span class="nx">server_ts</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>
    <span class="nx">vid_one_way</span> <span class="o">=</span> <span class="nx">vid_round_trip_time</span> <span class="o">-</span> <span class="nx">ack_one_way</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">vid_one_way</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>
<p>As we can see, calculating websocket message latency is not straightforward. It requires additional messages that needs to be sent which adds to the network load. In case the primary websocket connection is already throttled, a different dedicated websocket connection for measuring latency can be used to send ACK messages with condition that a client connect to same instance of server for both the socket connections to avoid clock skew between servers.</p>

  </div>
  <div class="PageNavigation">
  
  <div class="prevDiv">
    <a class="prev" href="/blog/2021/07/steady-by-aid-with-art/">&laquo; STEADY by AID with ART</a>
  </div>
  
  
  <div class="nextDiv">
    <a class="next" href="/blog/2022/06/messagepack-vs-base64/">Optimizing network footprint using MessagePack &raquo;</a>
  </div>
  
</div>
<!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="ankitbko/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/blog/2022/06/websocket-latency/" hidden></a>
</article>