<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Patterns for Vision on the Edge - Part 2 - Handling Multiple Consumers</h1><p class="page-description">Challenges in implementing Vision based solution using Python on Edge.</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-06-30T00:00:00-05:00" itemprop="datePublished">
        Jun 30, 2022
      </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name"><a href='https://twitter.com/ankitbko', target='_blank'>Ankit Sinha</a>, <a href='https://github.com/prabdeb', target='_blank'>Prabal Deb</a></span></span>
       • <span class="read-time" title="Estimated read time">
    
    
      8 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/blog/categories/#AI">AI</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#ML">ML</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#vision on edge">vision on edge</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#python">python</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#multiprocessing">multiprocessing</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#threading">threading</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#GIL">GIL</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#back-pressure">back-pressure</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#reactivex">reactivex</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#rxpy">rxpy</a>
        
      
      </p>
    

    
		<div class="d-flex flex-wrap flex-justify-start flex-items-center">
			<p class="page-description" style="margin-right: .5rem;">Source Code </p>
			<div class="page-description">
				<div class="px-2">
    <a href="https://github.com/ankitbko/vision-on-edge" role="button" target="_blank">
        <img class="notebook-badge-image" src="/blog/assets/badges/github.svg" alt="View On GitHub">
    </a>
</div>

			</div>
		</div>
	
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This post is the second part in a 2 part blog series on Patterns for implementing Vision on Edge. In the <a href="/blog/2022/06/vision-on-edge-part-1/">previous post</a>, we discussed two of the three common challenges faced when creating a Computer Vision based solution using Python on Edge.</p>

<p>In this post we will cover the third challenge i.e. reading the video frames from the source (camera) and distributing them to multiple consumers based on the frame rate supported by the individual consumers.</p>

<p>One of the most common ways to implement such a pattern is using the <a href="https://reactivex.io/">ReactiveX</a>.</p>

<p>ReactiveX is an API for asynchronous programming with observable streams which enables to multiplex stream of data to multiple consumers. Under the hood, ReactX is an implementation of <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer pattern</a>.</p>

<p>In our sample application, we read frames from camera in FrameProvider process and then we send the frame to two consumers - UI and Queue.</p>

<p>Behind the scenes, ReactiveX is enabling us to read stream of video frames (from source camera), split the stream into two different streams (one per consumer), independently apply sampling on each stream to adhere to different FPS requirement for the consumer, and transmit the frames to different consumers asynchronously.</p>

<p>Now let’s see how is this all implemented.</p>

<h2 id="reactivex-for-python-rxpy">ReactiveX for Python (RxPY)</h2>

<p><em>ReactiveX for Python (RxPY) is a library for composing asynchronous and event-based programs using observable collections and pipable query operators in Python.</em></p>

<p>As the concept of ReactiveX is vast, we will focus on 2 key aspects of this framework referenced in this sample application.</p>

<h3 id="observable">Observable</h3>

<p>An <em>Observable</em> emits items sequentially. Multiple <em>Observers</em> can <em>subscribe</em> to an <em>Observable</em> and react to the items as emitted by <em>Observable</em>. This enables better concurrency and non-blocking operations.</p>

<p>If we relate this concept to our problem, we can have an <em>Observer</em> that reads a frame from camera and emits it. And we can have two different <em>Observers</em> subscribed to it, one for emitting the frame to Queue and another for sending the frame in UI. In practice, we will have many more <em>Observers</em> in the pipeline to transform and modify the frames before we emit them to downstream consumers.</p>

<h3 id="operator">Operator</h3>

<p>There are multiple operators that are used in <code class="language-plaintext highlighter-rouge">ReactiveX</code> to compose the pipeline, where each operator is a function that takes an Observable, transforms the item and yields a new Observable. Let’s look at the following operators that we have used in this sample:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">map</code>: transform the items emitted by an Observable to a new Observable by applying a function to each item.</li>
  <li><code class="language-plaintext highlighter-rouge">filter</code>: filters the items emitted by an Observable using a predicate.</li>
  <li><code class="language-plaintext highlighter-rouge">sample</code>: emit the most recent items within periodic time intervals.</li>
  <li><code class="language-plaintext highlighter-rouge">interval</code>: emits a sequence of items spaced by a specified interval.</li>
  <li><code class="language-plaintext highlighter-rouge">share</code>: shares the items emitted by an Observable, by converting connectable Observable (that does not begin emitting items) to a ordinary Observable. By applying this operator we can prompt an Observable to begin emitting items</li>
  <li><code class="language-plaintext highlighter-rouge">do_action</code>: performs an action for each item emitted by an Observable.</li>
</ul>

<p>We can use these operators to perform several tasks like reading frame from camera, resizing the frame, sending to UI, etc.</p>

<h2 id="implementation">Implementation</h2>

<p>Lets take a look at how we have implemented the above concepts in the application. All the code is present in <code class="language-plaintext highlighter-rouge">frame_provider.py</code>.</p>

<p><img src="/blog/assets/images/posts/vision-on-edge-2/ReactiveX.png" alt="ReactiveX Implementation" /></p>

<h3 id="frame-stream">Frame Stream</h3>

<p>First task is to read the frames from the camera at a defined rate supported by the camera. To do this we make use of <code class="language-plaintext highlighter-rouge">interval</code> operator in <em>RxPY</em> to emit an event at defined interval. We then need to discard the invalid frames and encapsulate it in our own data structure.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">frame_stream</span> <span class="o">=</span> <span class="n">interval</span><span class="p">(</span><span class="n">frame_rate</span><span class="p">).</span><span class="n">pipe</span><span class="p">(</span>
    <span class="n">op</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">vid</span><span class="p">.</span><span class="n">read</span><span class="p">()),</span>  <span class="c1"># read frame
</span>    <span class="n">op</span><span class="p">.</span><span class="n">do_action</span><span class="p">(</span><span class="k">lambda</span> <span class="n">result</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">vid</span><span class="p">.</span><span class="nb">set</span><span class="p">(</span><span class="n">cv2</span><span class="p">.</span><span class="n">CAP_PROP_POS_FRAMES</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">False</span> <span class="k">else</span> <span class="bp">None</span><span class="p">),</span> <span class="c1"># restart video on completion
</span>    <span class="n">op</span><span class="p">.</span><span class="nb">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">result</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">True</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
    <span class="p">),</span>  <span class="c1"># filter None frames
</span>    <span class="n">op</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">result</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>  <span class="c1"># get frame
</span>    <span class="n">op</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="n">Frame</span><span class="p">(</span>
            <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span>
            <span class="n">correlation_id</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="p">.</span><span class="n">uuid4</span><span class="p">()),</span>
        <span class="p">)</span>
    <span class="p">),</span>  <span class="c1"># create frame object
</span>    <span class="n">op</span><span class="p">.</span><span class="n">share</span><span class="p">(),</span>  <span class="c1"># share frame stream
</span><span class="p">)</span>
</code></pre></div></div>

<p>Let’s take a look at step by step operations</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">interval(frame_rate)</code> - emits a sequence an event at a FPS rate for camera.</li>
  <li><code class="language-plaintext highlighter-rouge">map(lambda _: self.vid.read())</code> - discards the original event and emits the frame after reading it from camera using <code class="language-plaintext highlighter-rouge">vid.read()</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">do_action(...)</code> - required only if reading from video file instead of camera. Used to restart the video when EOF is reached.</li>
  <li><code class="language-plaintext highlighter-rouge">filter(lambda result: result[0] is True and result[1] is not None)</code> - filters out the invalid frames.</li>
  <li><code class="language-plaintext highlighter-rouge">map(...)</code> - create a Frame object, by adding additional information (<code class="language-plaintext highlighter-rouge">correlation_id</code>) to the frame.</li>
  <li><code class="language-plaintext highlighter-rouge">share</code> - returns an observable sequence that shares a single subscription to the underlying sequence.</li>
</ol>

<h3 id="ui-stream">UI Stream</h3>

<p>Next we want to subscribe to <em>Frame Stream</em>, sample the frames to match FPS required by UI, resize the frames and transmit it using websocket. The <code class="language-plaintext highlighter-rouge">sample</code> operator changes the frequency of the items being emitted for the downstream operators allowing us to change the FPS rate.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">frame_stream</span><span class="p">.</span><span class="n">pipe</span><span class="p">(</span>
    <span class="n">op</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">socket_fps</span><span class="p">),</span>
    <span class="n">op</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="n">Frame</span><span class="p">(</span>
            <span class="n">cv2</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">),</span>
            <span class="n">frame</span><span class="p">.</span><span class="n">correlation_id</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">),</span>
    <span class="n">op</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="n">Frame</span><span class="p">(</span>
            <span class="n">frame</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span>
            <span class="n">frame</span><span class="p">.</span><span class="n">correlation_id</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">),</span>
    <span class="n">op</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">_write_to_socket</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">)),</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Let’s take a look at step by step operations, that is being performed primarily on the Observer.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">sample(socket_fps)</code> - that samples the frame stream to send the frame to the UI at a FPS rate required by UI.</li>
  <li><code class="language-plaintext highlighter-rouge">map(...)</code> - resize the frame to the required size needed for UI.</li>
  <li><code class="language-plaintext highlighter-rouge">map(lambda frame: self._write_to_socket(frame=frame))</code> - send each frame to the UI.</li>
</ol>

<h3 id="queue-stream">Queue Stream</h3>

<p>Simultaneously we need to get frames from <em>Frame Stream</em> and send the frame to the Queue for performing frame processing. The <code class="language-plaintext highlighter-rouge">share</code> operator in <em>Frame Stream</em> allows us to share the stream between two different observers where each observer gets copy of same item as emitted from <em>Frame Stream</em>. We perform the same actions as we did with <em>UI Stream</em> but with different FPS rate and resize parameters.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">frame_stream</span><span class="p">.</span><span class="n">pipe</span><span class="p">(</span>
    <span class="n">op</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">queue_fps</span><span class="p">),</span>
    <span class="n">op</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="n">Frame</span><span class="p">(</span>
            <span class="n">cv2</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">),</span>
            <span class="n">frame</span><span class="p">.</span><span class="n">correlation_id</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">),</span>
    <span class="n">op</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">_write_to_queue</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">)),</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Let’s take a look at step by step operations, that is being performed primarily on the Observer.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">sample(queue_fps)</code> - samples the frame stream to send the frame to the Queue at a FPS rate required by frame processing.</li>
  <li><code class="language-plaintext highlighter-rouge">map(...)</code> - resize the frame to the required size needed for frame processing.</li>
  <li><code class="language-plaintext highlighter-rouge">map(lambda frame: self._write_to_queue(frame=frame))</code> - send each frame to the Queue.</li>
</ol>

<h3 id="subscribe-to-the-stream">Subscribe to the stream</h3>

<p>Now we have two observables - one from <em>UI Stream</em> and another from <em>Queue Stream</em>. We need to <em>subscribe</em> to the observables to start the pipelines.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">socket_result_stream</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span>
    <span class="n">on_next</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
    <span class="n">on_error</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ex</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">exception</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span>
    <span class="n">on_completed</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Completed frame stream"</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">queue_result_stream</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span>
    <span class="n">on_next</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
    <span class="n">on_error</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ex</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">exception</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span>
    <span class="n">on_completed</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Completed frame stream"</span><span class="p">),</span>
<span class="p">)</span>
</code></pre></div></div>

<p>Once subscribed, the operators will start receiving the frames from the Observable, which is an asynchronous and non-blocking operation.</p>

<h2 id="unit-test">Unit Test</h2>

<p>Conventional way of testing is not sufficient to test the <em>ReactiveX</em> code. We need to use <a href="(https://rxmarbles.com/)">Marble diagrams</a> to represent the behavior of an Observable and then we can can use it to assert the Observable as expected.</p>

<p>Also for mocking we can use <code class="language-plaintext highlighter-rouge">Hot</code> and <code class="language-plaintext highlighter-rouge">Cold</code> Observables. <em>A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle. A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.</em></p>

<p>Let’s have a look at the following unit test case for function <code class="language-plaintext highlighter-rouge">def _emit_frame_to_queue</code> in <code class="language-plaintext highlighter-rouge">frame_provider.py</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">from</span> <span class="nn">unittest.mock</span> <span class="kn">import</span> <span class="n">patch</span>
<span class="kn">from</span> <span class="nn">rx</span> <span class="kn">import</span> <span class="n">operators</span> <span class="k">as</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">rx.testing.marbles</span> <span class="kn">import</span> <span class="n">marbles_testing</span>
<span class="kn">from</span> <span class="nn">frame_provider</span> <span class="kn">import</span> <span class="n">FrameProvider</span><span class="p">,</span> <span class="n">Frame</span>


<span class="k">def</span> <span class="nf">print_marbles</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
    <span class="n">diagram</span> <span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">ops</span><span class="p">.</span><span class="n">to_marbles</span><span class="p">(</span><span class="n">timespan</span><span class="o">=</span><span class="n">ts</span><span class="p">)).</span><span class="n">run</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'got        "{}"'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">diagram</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">TestFrameProvider</span><span class="p">(</span><span class="n">unittest</span><span class="p">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="o">@</span><span class="n">patch</span><span class="p">(</span><span class="s">"frame_provider.cv2.resize"</span><span class="p">,</span> <span class="n">side_effect</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
    <span class="o">@</span><span class="n">patch</span><span class="p">(</span>
        <span class="s">"frame_provider.FrameProvider._write_to_queue"</span><span class="p">,</span> <span class="n">side_effect</span><span class="o">=</span><span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="bp">True</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">test__emit_frame_to_queue_samples_at_given_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">frame_rate</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">frame_provider</span> <span class="o">=</span> <span class="n">FrameProvider</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">10.0</span>
        <span class="n">mock_frame</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">marbles_testing</span><span class="p">(</span><span class="n">timespan</span><span class="o">=</span><span class="n">ts</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">cold</span><span class="p">,</span> <span class="n">hot</span><span class="p">,</span> <span class="n">exp</span><span class="p">):</span>
            <span class="n">e1</span> <span class="o">=</span> <span class="n">cold</span><span class="p">(</span>
                <span class="s">"-a-b-c---d-e-----|"</span><span class="p">,</span>
                <span class="p">{</span>
                    <span class="s">"a"</span><span class="p">:</span> <span class="n">mock_frame</span><span class="p">,</span>
                    <span class="s">"b"</span><span class="p">:</span> <span class="n">mock_frame</span><span class="p">,</span>
                    <span class="s">"c"</span><span class="p">:</span> <span class="n">mock_frame</span><span class="p">,</span>
                    <span class="s">"d"</span><span class="p">:</span> <span class="n">mock_frame</span><span class="p">,</span>
                    <span class="s">"e"</span><span class="p">:</span> <span class="n">mock_frame</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span>
                <span class="s">" -----c----d----e----|"</span><span class="p">,</span>
                <span class="p">{</span>
                    <span class="s">"c"</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="s">"d"</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="s">"e"</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="n">ex</span>

            <span class="n">result_stream</span> <span class="o">=</span> <span class="n">frame_provider</span><span class="p">.</span><span class="n">_emit_frame_to_queue</span><span class="p">(</span>
                <span class="n">e1</span><span class="p">,</span> <span class="n">frame_rate</span><span class="p">,</span> <span class="p">[</span><span class="mi">900</span><span class="p">,</span> <span class="mi">900</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">print_marbles</span><span class="p">(</span><span class="n">result_stream</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span>

            <span class="n">results</span> <span class="o">=</span> <span class="n">start</span><span class="p">(</span><span class="n">result_stream</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">results</span> <span class="o">==</span> <span class="n">expected</span>

</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>In this blog series, we discussed common challenges when implementing a vision based solution. In part 1 of the blog post, we discussed how to handle backpressure when ML model is unable to keep up to the FPS rate of camera. We also discussed how to run inference on ML model while concurrently performing other tasks. We learned the bottlenecks of <em>threading</em> and <em>GIL</em> in Python and how to leverage <em>multiprocessing</em> instead. In this article we saw how ReactiveX can be leveraged to multiplex the camera stream to multiple consumers in a asynchronous and non blocking manner.</p>

<h2 id="references">References</h2>

<ol>
  <li><a href="https://reactivex.io/">ReactiveX</a></li>
  <li><a href="https://rxpy.readthedocs.io/en/latest/">ReactiveX for Python (RxPY)</a></li>
  <li><a href="https://github.com/ReactiveX/RxPY">github.com/ReactiveX/RxPY</a></li>
  <li><a href="https://rxmarbles.com/">Interactive diagrams of Rx Observables</a></li>
</ol>

  </div>
  <div class="PageNavigation">
  
  <div class="prevDiv">
    <a class="prev" href="/blog/2022/06/vision-on-edge-part-1/">&laquo; Patterns for Vision on the Edge - Part 1 - Concurrent processing</a>
  </div>
  
  
  <div class="nextDiv">
    <a class="next" href="/blog/2025/08/prompt-engineering-kv-cache/">KV-Cache Aware Prompt Engineering - How Stable Prefixes Unlock 64% Latency Improvements &raquo;</a>
  </div>
  
</div>
<!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="ankitbko/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/blog/2022/06/vision-on-edge-part-2/" hidden></a>
</article>