<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">A better way to logging in Python</h1><p class="page-description">A generic logging decorator for python</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2021-04-15T00:00:00-05:00" itemprop="datePublished">
        Apr 15, 2021
      </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name"><a href='https://twitter.com/ankitbko', target='_blank'>Ankit Sinha</a></span></span>
       • <span class="read-time" title="Estimated read time">
    
    
      10 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/blog/categories/#python">python</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#decorators">decorators</a>
        
      
      </p>
    

    
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Any production application will likely have some guidelines regarding how and what needs to be logged in your application. More often these guidelines stem from common industry patterns such as “log all exceptions”. However implementing these guidelines are left to individual developers and leads to same set of logging statements repeated throughout the codebase. For instance to log all exceptions you would have a logging statement in every <code class="language-plaintext highlighter-rouge">except</code> block that captures exception and logs it under <code class="language-plaintext highlighter-rouge">ERROR</code> level. But the logging statement for same scenario may differ between developers due to their individual style of development. Overtime this leads to fragmented and inconsistent logging in the application. Moreover developers can make mistake and miss having logging statement at necessary places.</p>

<p>One approach to alleviate this problem is by utilizing Python’s decorator feature. This article will give a brief overview of decorators and demonstrate how to create a decorator to abstract these common logging statements. You can read more about decorators and variety of ways they can be utilized in this excellent <a href="https://realpython.com/primer-on-python-decorators/">Primer on Python Decorators</a>.</p>

<h2 id="what-are-decorators">What are decorators</h2>

<p>A decorator is a function that takes another function and extends it’s behavior without explicitly modifying it. These are also known as <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher-order functions</a>.</p>

<p>Python’s functions are <a href="https://en.wikipedia.org/wiki/First-class_citizen">first-class citizens</a>. This means functions can passed as argument or can be subject of assignment. So if you have a function <code class="language-plaintext highlighter-rouge">def sum(a, b=10)</code>, you can use it as any other object and drill down into its properties.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">sum</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="nb">sum</span> <span class="n">at</span> <span class="mh">0x7f35e9dde310</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">sum</span><span class="p">.</span><span class="n">__code__</span><span class="p">.</span><span class="n">co_varnames</span>  <span class="c1"># Names of local variables
</span><span class="p">(</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">)</span>
</code></pre></div></div>

<p>Since functions behave like an object, you could assign <code class="language-plaintext highlighter-rouge">sum</code> to another function. Then calling <code class="language-plaintext highlighter-rouge">sum</code> will call this other function instead of the one that we defined before. The decorators utilizes this behavior by assigning <code class="language-plaintext highlighter-rouge">sum</code> a new function which takes <code class="language-plaintext highlighter-rouge">sum</code> as parameter and wraps some additional logic around it thereby <em>extending</em> it without modifying the function itself.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># do something before `sum`
</span>        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># do something after `sum`
</span>        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="nb">sum</span> <span class="o">=</span> <span class="n">my_decorator</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">sum</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">my_decorator</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">locals</span><span class="o">&gt;</span><span class="p">.</span><span class="n">wrapper</span> <span class="n">at</span> <span class="mh">0x7f9c0359b0d0</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>This pattern is so common that Python has a syntactic sugar for decorating a function. So instead of <code class="language-plaintext highlighter-rouge">sum = my_decorator(sum)</code> we can use <code class="language-plaintext highlighter-rouge">@</code> symbol on top of <code class="language-plaintext highlighter-rouge">sum</code> method like this -</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">my_decorator</span> <span class="c1"># Equivalent to `sum = my_decorator(sum)` after the method
</span><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</code></pre></div></div>

<h2 id="logging-decorator">Logging Decorator</h2>

<p>We are going to create a decorator that handles two common logging scenarios - logging exceptions as <em>ERROR</em> and logging method arguments as <em>DEBUG</em> logs.</p>

<p>Lets start by capturing the exceptions and log it using python <code class="language-plaintext highlighter-rouge">logging</code> library.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logging</span><span class="p">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="n">getLogger</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="p">.</span><span class="n">exception</span><span class="p">(</span><span class="s">f"Exception raised in </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s">. exception: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">@</span><span class="n">log</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">"Something went wrong"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR:root:Exception raised <span class="k">in </span>foo. exception: Something went wrong
Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">"&lt;REDACTED&gt;/foo.py"</span>, line 15, <span class="k">in </span>wrapper
    result <span class="o">=</span> func<span class="o">(</span><span class="k">*</span>args, <span class="k">**</span>kwargs<span class="o">)</span>
  File <span class="s2">"&lt;REDACTED&gt;/foo.py"</span>, line 28, <span class="k">in </span>foo
    raise Exception<span class="o">(</span><span class="s2">"Something went wrong"</span><span class="o">)</span>
Exception: Something went wrong
</code></pre></div></div>

<p>In addition to setting up the <code class="language-plaintext highlighter-rouge">logger</code>, we have also used <a href="https://docs.python.org/3/library/functools.html#functools.wraps">@functools.wraps</a> decorator. The <code class="language-plaintext highlighter-rouge">wraps</code> decorator updates the <code class="language-plaintext highlighter-rouge">wrapper</code> function to look like <code class="language-plaintext highlighter-rouge">func</code>. Our <code class="language-plaintext highlighter-rouge">@log</code> decorator can now be used on any function to catch every exception from <em>wrapped</em> function and log it in a consistent manner.</p>

<p>Since <code class="language-plaintext highlighter-rouge">wrapper</code> function accepts all arguments (<code class="language-plaintext highlighter-rouge">*args and **kwargs</code>), the <code class="language-plaintext highlighter-rouge">@log</code> decorator can be extended to capture all the parameters passed to the decorated function. We can do this by just iterating over <em>args</em> and <em>kwargs</em> and joining them to form string message to log.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">args_repr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="n">kwargs_repr</span> <span class="o">=</span> <span class="p">[</span><span class="s">f"</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s">=</span><span class="si">{</span><span class="n">v</span><span class="err">!</span><span class="n">r</span><span class="si">}</span><span class="s">"</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="s">", "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">args_repr</span> <span class="o">+</span> <span class="n">kwargs_repr</span><span class="p">)</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="s">f"function </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> called with args </span><span class="si">{</span><span class="n">signature</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="p">.</span><span class="n">exception</span><span class="p">(</span><span class="s">f"Exception raised in </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s">. exception: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">DEBUG</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">function</span> <span class="nb">sum</span> <span class="n">called</span> <span class="k">with</span> <span class="n">args</span> <span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span>
<span class="mi">30</span>
</code></pre></div></div>

<p>We log the parameters in <em>DEBUG</em> level as we don’t want our logs cluttered with all functions arguments. Debug logging can be toggled on our systems as and when necessary. <strong>Keep in mind that this will write all argument values into log including any PII data or secrets</strong>.</p>

<p>This basic logging decorator looks good and already does what we originally set out to achieve. As long as a method is decorated with <code class="language-plaintext highlighter-rouge">@log</code> decorator we will log any exception raised within it and all arguments passed to it.</p>

<p>However in a real project, the <code class="language-plaintext highlighter-rouge">logger</code> can itself be abstracted away into its own class that initializes a logger based on certain configuration (such as push log to a cloud sink). In this case its useless to log into console by creating our own logger in the <code class="language-plaintext highlighter-rouge">@log</code> decorator. We need a way to pass an existing <code class="language-plaintext highlighter-rouge">logger</code> into our decorator at runtime. To do this we can extend the <code class="language-plaintext highlighter-rouge">@log</code> decorator to accept <code class="language-plaintext highlighter-rouge">logger</code> as an argument.</p>

<p>To mimic this scenario we will start with having a class that creates a creates logger for us. For now we will create the basic logger but you can imagine the class configuring the behavior of the logger as required.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyLogger</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logging</span><span class="p">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="p">.</span><span class="n">DEBUG</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">logging</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</code></pre></div></div>

<p>Since at the time of writing the decorator we do not know whether the underlying function will be passing us <code class="language-plaintext highlighter-rouge">MyLogger</code> or <code class="language-plaintext highlighter-rouge">logging.logger</code> or no logger at all, our generic decorator will have be able to handle all of them.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="k">def</span> <span class="nf">get_default_logger</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">MyLogger</span><span class="p">().</span><span class="n">get_logger</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">_func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">my_logger</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MyLogger</span><span class="p">,</span> <span class="n">logging</span><span class="p">.</span><span class="n">Logger</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator_log</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">my_logger</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">logger</span> <span class="o">=</span> <span class="n">get_default_logger</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_logger</span><span class="p">,</span> <span class="n">MyLogger</span><span class="p">):</span>
                    <span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span><span class="p">.</span><span class="n">get_logger</span><span class="p">(</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span> <span class="o">=</span> <span class="n">my_logger</span>
            <span class="n">args_repr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="n">kwargs_repr</span> <span class="o">=</span> <span class="p">[</span><span class="s">f"</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s">=</span><span class="si">{</span><span class="n">v</span><span class="err">!</span><span class="n">r</span><span class="si">}</span><span class="s">"</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="s">", "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">args_repr</span> <span class="o">+</span> <span class="n">kwargs_repr</span><span class="p">)</span>
            <span class="n">logger</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="s">f"function </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> called with args </span><span class="si">{</span><span class="n">signature</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="p">.</span><span class="n">exception</span><span class="p">(</span><span class="s">f"Exception raised in </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s">. exception: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="k">if</span> <span class="n">_func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_log</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_log</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span>
</code></pre></div></div>

<p>The above code looks quite scary but let me summarize it. The <code class="language-plaintext highlighter-rouge">@log</code> decorator now handles three different scenarios -</p>

<ul>
  <li>
    <p><strong>No logger is passed</strong>: This is same scenario what we have been doing up until before this. The decorator is simply used as <code class="language-plaintext highlighter-rouge">@log</code> statement on top of the function. In this case the decorator gets a logger by calling <code class="language-plaintext highlighter-rouge">get_default_logger</code> method and uses it for rest of the method.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">MyLogger</code> is passed</strong>: Our <code class="language-plaintext highlighter-rouge">@log</code> decorator can now accept instance of <code class="language-plaintext highlighter-rouge">MyLogger</code> as an argument. It can then call <code class="language-plaintext highlighter-rouge">MyLogger.get_logger</code> method to create a nested logger and use it rest of the way.</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">log</span><span class="p">(</span><span class="n">my_logger</span><span class="o">=</span><span class="n">MyLogger</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">logging.logger</code> is passed</strong>: In this third scenario we can pass the logger itself instead of passing <code class="language-plaintext highlighter-rouge">MyLogger</code> class.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lg</span> <span class="o">=</span> <span class="n">MyLogger</span><span class="p">().</span><span class="n">get_logger</span><span class="p">()</span>

<span class="o">@</span><span class="n">log</span><span class="p">(</span><span class="n">my_logger</span><span class="o">=</span><span class="n">lg</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<p>We are still not done. Even in current form our log decorator is restricted. One limitation is that we <em>must</em> have <code class="language-plaintext highlighter-rouge">logger</code> or <code class="language-plaintext highlighter-rouge">MyLogger</code> available <em>before</em> the method we want to decorate. In other words the reference to logger <em>must</em> exist before the method itself exists. This may work in cases where the target function is part of a class and the class <code class="language-plaintext highlighter-rouge">__init__</code> method can instantiate the logger, but it won’t work with functions outside the context of class. In many real world applications we wont have each module or function creating their own logger. Instead we may want to pass the logger to the function itself. The <code class="language-plaintext highlighter-rouge">logger</code> or <code class="language-plaintext highlighter-rouge">MyLogger</code> will be dependency injected into downstream methods. In other words a function may have logger passed to it in its parameter.</p>

<p>But if the function is part of a class then the <code class="language-plaintext highlighter-rouge">logger</code> will be injected into class itself and not into every method of the class. In this case we would want to use the logger available to our class instead.</p>

<p>So our objective is to capture the <code class="language-plaintext highlighter-rouge">logger</code> passed as the argument <em>to the decorated</em> function <strong>or</strong> passed to the <em>class constructor of our decorated function</em>, and use it to log <em>from the decorator</em> itself. By doing this our decorator can be completely decoupled from the logger itself and will utilize whatever logger is available to the underlying method at runtime.</p>

<p>To do this we will iterate over the <code class="language-plaintext highlighter-rouge">args</code> and <code class="language-plaintext highlighter-rouge">kwargs</code> argument and check if we get <code class="language-plaintext highlighter-rouge">logger</code> in any of them. To check if the function is part of the class, we can check if first argument of <code class="language-plaintext highlighter-rouge">args</code> has attribute <code class="language-plaintext highlighter-rouge">__dict__</code>. If the first argument has attribute <code class="language-plaintext highlighter-rouge">__dict__</code> we will iterate over the <code class="language-plaintext highlighter-rouge">__dict__.values()</code> and check if one of these values is our logger. Finally if nothing works we will default to <code class="language-plaintext highlighter-rouge">get_default_logger</code> method.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">_func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">my_logger</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MyLogger</span><span class="p">,</span> <span class="n">logging</span><span class="p">.</span><span class="n">Logger</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator_log</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">logger</span> <span class="o">=</span> <span class="n">get_default_logger</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">my_logger</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">first_args</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="bp">None</span><span class="p">)</span>  <span class="c1"># capture first arg to check for `self`
</span>                    <span class="n">logger_params</span> <span class="o">=</span> <span class="p">[</span>  <span class="c1"># does kwargs have any logger
</span>                        <span class="n">x</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">values</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">logging</span><span class="p">.</span><span class="n">Logger</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MyLogger</span><span class="p">)</span>
                    <span class="p">]</span> <span class="o">+</span> <span class="p">[</span>  <span class="c1"># # does args have any logger
</span>                        <span class="n">x</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">logging</span><span class="p">.</span><span class="n">Logger</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MyLogger</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">first_args</span><span class="p">,</span> <span class="s">"__dict__"</span><span class="p">):</span>  <span class="c1"># is first argument `self`
</span>                        <span class="n">logger_params</span> <span class="o">=</span> <span class="n">logger_params</span> <span class="o">+</span> <span class="p">[</span>
                            <span class="n">x</span>
                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">first_args</span><span class="p">.</span><span class="n">__dict__</span><span class="p">.</span><span class="n">values</span><span class="p">()</span>  <span class="c1"># does class (dict) members have any logger
</span>                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">logging</span><span class="p">.</span><span class="n">Logger</span><span class="p">)</span>
                            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MyLogger</span><span class="p">)</span>
                        <span class="p">]</span>
                    <span class="n">h_logger</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">logger_params</span><span class="p">),</span> <span class="n">MyLogger</span><span class="p">())</span>  <span class="c1"># get the next/first/default logger
</span>                <span class="k">else</span><span class="p">:</span>
                    <span class="n">h_logger</span> <span class="o">=</span> <span class="n">my_logger</span>  <span class="c1"># logger is passed explicitly to the decorator
</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h_logger</span><span class="p">,</span> <span class="n">MyLogger</span><span class="p">):</span>
                    <span class="n">logger</span> <span class="o">=</span> <span class="n">h_logger</span><span class="p">.</span><span class="n">get_logger</span><span class="p">(</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span> <span class="o">=</span> <span class="n">h_logger</span>

                <span class="n">args_repr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
                <span class="n">kwargs_repr</span> <span class="o">=</span> <span class="p">[</span><span class="s">f"</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s">=</span><span class="si">{</span><span class="n">v</span><span class="err">!</span><span class="n">r</span><span class="si">}</span><span class="s">"</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">items</span><span class="p">()]</span>
                <span class="n">signature</span> <span class="o">=</span> <span class="s">", "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">args_repr</span> <span class="o">+</span> <span class="n">kwargs_repr</span><span class="p">)</span>
                <span class="n">logger</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="s">f"function </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> called with args </span><span class="si">{</span><span class="n">signature</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
            <span class="k">except</span> <span class="nb">Exception</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="p">.</span><span class="n">exception</span><span class="p">(</span><span class="s">f"Exception raised in </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s">. exception: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="k">if</span> <span class="n">_func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_log</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_log</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span>
</code></pre></div></div>

<p>The above decorator is generic enough to work for 2 more scenarios in addition to 3 scenarios we discussed before -</p>

<ul>
  <li>Either <code class="language-plaintext highlighter-rouge">logger</code> or <code class="language-plaintext highlighter-rouge">MyLogger</code> is passed to the decorated method</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">log</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">logger</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="o">@</span><span class="n">log</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> <span class="c1"># Named parameter
</span>    <span class="k">pass</span>

<span class="n">foo</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">MyLogger</span><span class="p">())</span>  <span class="c1"># OR foo(10, 20, MyLogger().get_logger())
</span><span class="n">bar</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">MyLogger</span><span class="p">())</span>  <span class="c1"># OR bar(10, b=20, logger=MyLogger().get_logger())
</span></code></pre></div></div>

<ul>
  <li>Either <code class="language-plaintext highlighter-rouge">logger</code> or <code class="language-plaintext highlighter-rouge">MyLogger</code> is passed to class <code class="language-plaintext highlighter-rouge">__init__</code> method hosting the decorated function</li>
</ul>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">lg</span> <span class="o">=</span> <span class="n">logger</span>

    <span class="o">@</span><span class="n">log</span>
    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">Foo</span><span class="p">(</span><span class="n">MyLogger</span><span class="p">()).</span><span class="nb">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>  <span class="c1"># OR Foo(MyLogger().get_logger()).sum(10, b=20)
</span></code></pre></div></div>

<p>One additional thing we have done is to wrap all the code <em>before</em> calling the decorated function <code class="language-plaintext highlighter-rouge">func</code> in a <code class="language-plaintext highlighter-rouge">try - except</code> block. We don’t want the execution to fail due to problems in logging even before the target function is called. In no case our logging logic should cause failure in the system.</p>

<h1 id="conclusion">Conclusion</h1>

<p>The above decorator is a good starting point and can be extended or simplified according to the requirements. It reduces the chance of missing out on exception logging and standardizes the error messages across the application.</p>

<p>Reach out to me in the comments below for any questions that you may have.</p>

  </div>
  <div class="PageNavigation">
  
  <div class="prevDiv">
    <a class="prev" href="/blog/2021/01/azdo-pr-vscode-extension/">&laquo; Azure Devops Pull Request Extension for VS Code</a>
  </div>
  
  
  <div class="nextDiv">
    <a class="next" href="/blog/2021/07/steady-by-aid-with-art/">STEADY by AID with ART &raquo;</a>
  </div>
  
</div>
<!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="ankitbko/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/blog/2021/04/logging-in-python/" hidden></a>
</article>